1. There is an array of objects - lets name it as referenceData
2. I have a form created using react-hook-form
3. The fields to be displayed are passed to a reusable form component in form of array of objects with config of name, label, required, disabled etc.
4. The form has few common fields and some displayed within useFieldArray
5. Most of the fields are dropdown options where options are based on referenceData and cascade filtering. E.g Field C will have list of options based on what's
selected on Field A  (maps to key A in referenceData) & Field B (maps to key B in referenceData) - what results after filtering for key C. It goes like that
till Field F. All these fields are part of common fields
6. Field G is in useFieldArray - cascade filtering based on Field A,B,C,D,E,F.
7. For some value selected in Field G, e.g. XYZ, the field F is not applicable - so its set to empty (if anything was selected prior) and disabled
8. But as soon as Field E or any previous field changes - Field F should be as before (enabled & reset) and Field G should be set to empty with no options since Field F
will be blank now & cascading filtering won't result in any options
9. Currently using custom hooks for each field that does the cascading filtering, setting options list based on referenceData 


How to handle the above inter dependency case for Field G and F

This is a classic cascading + conditional invalidation problem, and the key issue is ownership of state transitions between F (common field) and G (fieldArray field).

Right now, because each field has its own hook, you‚Äôre missing a single place that understands cross-field rules like:

‚ÄúIf G === XYZ ‚Üí F becomes N/A
If any of A‚ÄìE changes ‚Üí F reverts, G resets‚Äù

Below is a clean, scalable pattern that works very well with react-hook-form.

Core Principle

üëâ Separate ‚Äúoption derivation‚Äù from ‚Äúbusiness rules‚Äù

Cascading options = pure derivation from referenceData

Inter-field rules = centralized effects driven by watch()

High-Level Strategy

Keep all cascading option logic pure

Functions like getOptionsForF(a,b,c,d,e)

No side effects inside option hooks

Use useWatch + useEffect for inter-dependency rules

One effect handles G ‚Üí F

Another handles A‚ÄìE ‚Üí reset F & G

Disable fields via derived state, not stored state

disabled={isFDisabled} instead of setting it in form state

Step 1: Watch the Relevant Fields
const [a, b, c, d, e, f] = useWatch({
  control,
  name: ['fieldA', 'fieldB', 'fieldC', 'fieldD', 'fieldE', 'fieldF']
});

const fieldGArray = useWatch({
  control,
  name: 'fieldG'
});

Step 2: Detect ‚ÄúXYZ‚Äù in Field G
const isFNotApplicable = useMemo(() => {
  return fieldGArray?.some(item => item.value === 'XYZ');
}, [fieldGArray]);

Step 3: Rule 1 ‚Äî If G = XYZ ‚Üí Clear & Disable F
useEffect(() => {
  if (isFNotApplicable) {
    setValue('fieldF', null, { shouldDirty: true });
  }
}, [isFNotApplicable, setValue]);

<FieldF
  disabled={isFNotApplicable}
  options={isFNotApplicable ? [] : optionsForF}
/>


‚úîÔ∏è No infinite loops
‚úîÔ∏è No coupling inside Field F hook

Step 4: Rule 2 ‚Äî If A‚ÄìE Changes ‚Üí Reset F & G

Track previous values to detect upstream changes:

const prevDepsRef = useRef({ a, b, c, d, e });

useEffect(() => {
  const prev = prevDepsRef.current;
  const changed =
    prev.a !== a ||
    prev.b !== b ||
    prev.c !== c ||
    prev.d !== d ||
    prev.e !== e;

  if (changed) {
    // Reset F
    setValue('fieldF', null);
    
    // Reset G fieldArray
    setValue('fieldG', []);
  }

  prevDepsRef.current = { a, b, c, d, e };
}, [a, b, c, d, e, setValue]);

Step 5: Field G Options Depend on F
const optionsForG = useMemo(() => {
  if (!f) return [];
  return getOptionsForG(referenceData, a, b, c, d, e, f);
}, [referenceData, a, b, c, d, e, f]);

Why This Works
‚úÖ No circular updates

G ‚Üí F is handled in one direction

A‚ÄìE ‚Üí F & G reset handled separately

‚úÖ No ‚Äúsmart fields‚Äù

Fields don‚Äôt know about each other

Only the form orchestration layer does

‚úÖ Scales to more rules

Add rules like:

‚ÄúIf F = ABC ‚Üí hide H‚Äù

without touching field hooks.

Recommended Folder Structure
/hooks
  useFieldOptions.ts     // pure option derivation
  useFormRules.ts        // inter-field effects

/forms
  ReusableForm.tsx

TL;DR Pattern
Concern	Where it lives
Cascading dropdown options	Pure hooks / utils
Disable / reset logic	useEffect + useWatch
Business rules	Centralized
Field components	Dumb & reusable



Below is a working, minimal-but-realistic example showing how to wire everything together with react-hook-form, including:

Common cascading fields A‚ÄìF

useFieldArray for G

Centralized inter-dependency rules

Pure option derivation from referenceData

Proper reset / disable behavior for F ‚Üî G

I‚Äôll keep UI simple (native <select>), but the pattern is identical for MUI / Ant / custom selects.

1Ô∏è‚É£ Sample referenceData
type RefItem = {
  A: string;
  B: string;
  C: string;
  D: string;
  E: string;
  F: string;
  G: string;
};

export const referenceData: RefItem[] = [
  { A: 'A1', B: 'B1', C: 'C1', D: 'D1', E: 'E1', F: 'F1', G: 'G1' },
  { A: 'A1', B: 'B1', C: 'C1', D: 'D1', E: 'E1', F: 'F2', G: 'XYZ' },
  { A: 'A1', B: 'B2', C: 'C2', D: 'D2', E: 'E2', F: 'F3', G: 'G2' },
];

2Ô∏è‚É£ Pure Option Utilities (NO side effects)
const uniq = (arr: string[]) => [...new Set(arr)];

export function getOptions(
  data: RefItem[],
  keys: Partial<RefItem>,
  target: keyof RefItem
) {
  return uniq(
    data
      .filter(item =>
        Object.entries(keys).every(
          ([k, v]) => !v || item[k as keyof RefItem] === v
        )
      )
      .map(item => item[target])
  );
}

3Ô∏è‚É£ Reusable Select Component
type SelectProps = {
  label: string;
  value?: string;
  options: string[];
  disabled?: boolean;
  onChange: (v: string) => void;
};

const SelectField = ({
  label,
  value,
  options,
  disabled,
  onChange,
}: SelectProps) => (
  <label style={{ display: 'block', marginBottom: 12 }}>
    {label}
    <select
      value={value ?? ''}
      disabled={disabled}
      onChange={e => onChange(e.target.value || '')}
    >
      <option value="">--</option>
      {options.map(o => (
        <option key={o} value={o}>
          {o}
        </option>
      ))}
    </select>
  </label>
);

4Ô∏è‚É£ Form With Centralized Rules
import { useForm, useFieldArray, useWatch } from 'react-hook-form';

type FormValues = {
  A?: string;
  B?: string;
  C?: string;
  D?: string;
  E?: string;
  F?: string;
  G: { value?: string }[];
};

export function CascadingForm() {
  const { control, setValue } = useForm<FormValues>({
    defaultValues: { G: [{}] },
  });

  const { fields } = useFieldArray({
    control,
    name: 'G',
  });

  const [A, B, C, D, E, F] = useWatch({
    control,
    name: ['A', 'B', 'C', 'D', 'E', 'F'],
  });

  const G = useWatch({ control, name: 'G' });

  // üîπ Options
  const optionsA = getOptions(referenceData, {}, 'A');
  const optionsB = getOptions(referenceData, { A }, 'B');
  const optionsC = getOptions(referenceData, { A, B }, 'C');
  const optionsD = getOptions(referenceData, { A, B, C }, 'D');
  const optionsE = getOptions(referenceData, { A, B, C, D }, 'E');
  const optionsF = getOptions(referenceData, { A, B, C, D, E }, 'F');
  const optionsG = F
    ? getOptions(referenceData, { A, B, C, D, E, F }, 'G')
    : [];

  // üîπ Rule: G === XYZ ‚Üí F N/A
  const isFDisabled = G?.some(g => g.value === 'XYZ');

  // Clear F when disabled
  React.useEffect(() => {
    if (isFDisabled) {
      setValue('F', undefined);
    }
  }, [isFDisabled, setValue]);

  // üîπ Rule: A‚ÄìE changes ‚Üí reset F & G
  const prevDeps = React.useRef({ A, B, C, D, E });

  React.useEffect(() => {
    const prev = prevDeps.current;
    const changed =
      prev.A !== A ||
      prev.B !== B ||
      prev.C !== C ||
      prev.D !== D ||
      prev.E !== E;

    if (changed) {
      setValue('F', undefined);
      setValue('G', []);
    }

    prevDeps.current = { A, B, C, D, E };
  }, [A, B, C, D, E, setValue]);

  return (
    <>
      <SelectField label="A" value={A} options={optionsA} onChange={v => setValue('A', v)} />
      <SelectField label="B" value={B} options={optionsB} onChange={v => setValue('B', v)} />
      <SelectField label="C" value={C} options={optionsC} onChange={v => setValue('C', v)} />
      <SelectField label="D" value={D} options={optionsD} onChange={v => setValue('D', v)} />
      <SelectField label="E" value={E} options={optionsE} onChange={v => setValue('E', v)} />

      <SelectField
        label="F"
        value={F}
        options={isFDisabled ? [] : optionsF}
        disabled={isFDisabled}
        onChange={v => setValue('F', v)}
      />

      <h4>Field G (FieldArray)</h4>
      {fields.map((field, i) => (
        <SelectField
          key={field.id}
          label={`G[${i}]`}
          value={G?.[i]?.value}
          options={optionsG}
          onChange={v => setValue(`G.${i}.value`, v)}
        />
      ))}
    </>
  );
}

5Ô∏è‚É£ What This Example Demonstrates

‚úîÔ∏è Cascading options (A ‚Üí F ‚Üí G)
‚úîÔ∏è G disables & clears F when XYZ selected
‚úîÔ∏è Upstream change resets downstream fields
‚úîÔ∏è No circular updates
‚úîÔ∏è Works with any reusable form renderer

6Ô∏è‚É£ Key Takeaways

Options = pure derivation

Rules = effects at form level

Disable is derived, not stored

useWatch is your orchestration tool



